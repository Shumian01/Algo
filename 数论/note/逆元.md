### 1. **逆元的定义**

****

对于一个整数 **a** 和一个模 **p**，如果存在一个整数 **x**，使得：

a *  x =1 (mod p)

那么称x为a模p意义下的逆元

**从上面看出gcd(a,p)=1,a与p互质   当且仅当a与p 互质才存在a的逆元 x**



### 扩展欧几里得算法求逆元

### 2. **线性同余方程**

上面的逆元问题可以转化为解线性同余方程：

a * x===1(mod m)

即，存在整数 k 使得：

ax=km+1

可以写作：

ax-km=1 —>ax+my=1 —>ax+by=1 (k=y)

那么我们可以使用扩展欧几里得算法求出x





###  贝祖定理

贝祖定理告诉我们，对于任意两个整数 **a**和**m**，如果gcd(a,m)=1，那么存在整数 \( x \) 和 \( y \)，使得：



**ax+my=1**



这里的 **x** 就是我们所求的**a**在模 \( m \) 意义下的逆元。

### 4. 扩展欧几里得算法

扩展欧几里得算法可以用来求解贝祖定理中的 \( x \) 和 \( y \)。算法基于欧几里得算法，它递归地计算两个数的最大公约数（GCD），同时在递归过程中利用反向代入的方法，求得对应的 \( x \) 和 \( y \)。

#### 扩展欧几里得算法步骤

1. **欧几里得算法**：通过不断取模，计算两个数 \( a \) 和 \( m \) 的 GCD。

2. **扩展步骤**：在计算 GCD 的过程中，通过反向推导，计算出 \( x \) 和 \( y \) 的值。

3. **求解逆元**：最终得到的 \( x \) 即为 \( a \) 在模 \( m \) 意义下的逆元。

```c++
int exgcd(int a,int b,int &x,int &y)
{
	if(!b)
    {
        x=1,y=0;
        return a;
    }
	int d=exgcd(b,a%b,y,x);
	y-=a/b*x;    
	return d;
}


```

